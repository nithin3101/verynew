#*****************************
# FEATURE LEARNING
#******************************

# IMPORTS
# ===========================
import os
import numpy as np
import tensorflow as tf

from tensorflow.keras.preprocessing.image import load_img, img_to_array, ImageDataGenerator
from tensorflow.keras.applications.densenet import DenseNet169, preprocess_input
from tensorflow.keras.models import Model, load_model
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras import backend as K

import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import cv2
from io import BytesIO
from PIL import Image
import requests


# ===========================
# CLASS LABELS
# ===========================
classes = [
    'Bacterial_spot', 'Early_blight', 'Late_blight', 'Leaf_Mold',
    'Septoria_leaf_spot', 'Spider_mites Two-spotted_spider_mite',
    'Target_spot', 'Tomato_Yellow_Leaf_Curl_Virus',
    'Tomato_mosaic_virus', 'healthy', 'powdery_mildew'
]

# LOAD FEATURE EXTRACTOR

feature_extractor = DenseNet169(
    weights='imagenet',
    include_top=False,
    pooling='avg',
    input_shape=(224, 224, 3)
)

# ===========================
# LOAD YOUR CLASSIFIER
# ===========================
classifier = load_model('/content/drive/MyDrive/feature_densenet169_tomato.hdf5')


# ===========================
# BUILD COMBINED MODEL FOR GRAD-CAM
# ===========================
x = feature_extractor.output
preds = classifier(x)
combined_model = Model(inputs=feature_extractor.input, outputs=preds)


# ===========================
# DATA GENERATOR (OPTIONAL EVALUATION)
# ===========================
eval_dir = '/content/dataset/Tomato_Leaf_Disease_Classification_Dataset/valid'
eval_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)

eval_gen = eval_datagen.flow_from_directory(
    eval_dir,
    target_size=(224,224),
    batch_size=32,
    shuffle=False,
    class_mode='categorical'
)

# Extract features
features = feature_extractor.predict(eval_gen, steps=len(eval_gen))
loss = classifier.evaluate(features, eval_gen.classes)
print("Classifier evaluation:", loss)


# ===========================
# PREDICTION FUNCTIONS
# ===========================
def preprocess_image(img):
    x = img_to_array(img) / 255.0
    return np.expand_dims(x, axis=0)

def predict_from_image_path(path):
    img = load_img(path, target_size=(224, 224))
    x = preprocess_image(img)
    preds = combined_model.predict(x)
    idx = np.argmax(preds)
    return idx, classes[idx]

def predict_image(im):
    x = img_to_array(im)
    x = preprocess_input(x)
    x = np.expand_dims(x, axis=0)

    pred = combined_model.predict(x)
    idx = np.argmax(pred)
    return idx, classes[idx]

def predict_from_image_url(url):
    res = requests.get(url)
    im = Image.open(BytesIO(res.content))
    im = im.convert("RGB")
    im = im.resize((224, 224))
    return predict_image(im)



# ------------------------
# GRAD-CAM
# ------------------------
def grad_CAM(path):

    # Load & preprocess image
    img = load_img(path, target_size=(224, 224))
    x = preprocess_image(img)

    # Predict
    preds = combined_model.predict(x)
    class_index = np.argmax(preds)

    # Last conv layer of DenseNet169
    last_conv_layer = combined_model.get_layer("conv5_block32_concat")

    # Create model for Grad-CAM
    grad_model = tf.keras.models.Model(
        [combined_model.inputs],
        [last_conv_layer.output, combined_model.output]
    )

    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(x)
        loss = predictions[:, class_index]

    # Compute gradients
    grads = tape.gradient(loss, conv_outputs)

    # Global average pooling of gradients
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    conv_outputs = conv_outputs[0].numpy()
    pooled_grads = pooled_grads.numpy()

    # Weight channels by gradient strength
    for i in range(pooled_grads.shape[-1]):
        conv_outputs[:, :, i] *= pooled_grads[i]

    # Heatmap from channel-wise mean
    heatmap = np.mean(conv_outputs, axis=-1)

    # Normalize heatmap
    heatmap = np.maximum(heatmap, 0)
    heatmap /= np.max(heatmap)

    # Load original image (for overlay)
    img = cv2.imread(path)
    img = cv2.resize(img, (224, 224))

    heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))
    heatmap = np.uint8(255 * heatmap)

    heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    superimposed_img = cv2.addWeighted(img, 0.6, heatmap, 0.4, 0)

    # Save result
    cv2.imwrite("gradcam_result.jpg", superimposed_img)
    print("Grad-CAM saved as gradcam_result.jpg")


    
def show_prediction_and_gradcam(path):
    # ---- 1. Prediction ----
    idx, label = predict_from_image_path(path)
    print("Predicted Class:", label)

    # ---- 2. Run Grad-CAM ----
    grad_CAM(path)   # This will save: gradcam_result.jpg

    # ---- 3. Load original + GradCAM ----
    original = cv2.imread(path)
    original = cv2.cvtColor(original, cv2.COLOR_BGR2RGB)

    grad = cv2.imread("gradcam_result.jpg")
    grad = cv2.cvtColor(grad, cv2.COLOR_BGR2RGB)

    # ---- 4. Show them ----
    plt.figure(figsize=(14, 6))

    # Original
    plt.subplot(1, 2, 1)
    plt.title("Original Image")
    plt.imshow(original)
    plt.axis("off")

    # Grad-CAM
    plt.subplot(1, 2, 2)
    plt.title(f"Grad-CAM Heatmap ({label})")
    plt.imshow(grad)
    plt.axis("off")

    plt.show()

    
# ===========================
# TEST SINGLE IMAGE
# ===========================
path = '/content/drive/MyDrive/Tomato_Leaf_Disease_Classification_Dataset/Tomato_Leaf_Disease_Classification_Dataset/valid/Bacterial_spot/01d9fc8d-5083-468d-a583-885f33517cdd___GCREC_Bact.Sp 3422.JPG'

print(predict_from_image_path(path))
grad_CAM(path)

path = '/content/dataset/Tomato_Leaf_Disease_Classification_Dataset/valid/Target_Spot/003a5321-0430-42dd-a38d-30ac4563f4ba___Com.G_TgS_FL 8121_180deg.JPG'

show_prediction_and_gradcam(path)

# ===========================
# TEST FULL DATASET WITH GRAD-CAM ON WRONG PREDICTIONS
# ===========================
base_folder = eval_dir

for i, c in enumerate(classes):
    folder = os.path.join(base_folder, c)
    if not os.path.exists(folder):
        print("Missing:", folder)
        continue

    count = 0

    for file in os.listdir(folder):
        if file.lower().endswith(('.jpg','.jpeg','.png')):
            img_path = os.path.join(folder, file)

            p, name = predict_from_image_path(img_path)

            if p == i:
                print(file, p, name)
            else:
                print(file, p, name, "**INCORRECT**")
                grad_CAM(img_path)

            count += 1
            if count == 2:  # limit to 50 images per class
                break

